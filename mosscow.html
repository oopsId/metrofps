<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Moscow Metro FPS</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Arial', sans-serif;
        }
        
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #game-canvas, #hud-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        #hud-canvas {
            pointer-events: none;
        }
        
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            color: white;
            font-family: 'Arial', sans-serif;
        }
        
        #health-bar {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 200px;
            height: 30px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 2px solid #333;
            border-radius: 5px;
            overflow: hidden;
        }
        
        #health-fill {
            height: 100%;
            width: 100%;
            background-color: #e74c3c;
            transition: width 0.3s;
        }
        
        #ammo-display {
            position: absolute;
            bottom: 20px;
            right: 20px;
            font-size: 24px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px 15px;
            border-radius: 5px;
        }
        
        #weapon-display {
            position: absolute;
            bottom: 70px;
            right: 20px;
            font-size: 18px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 8px 12px;
            border-radius: 5px;
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            box-sizing: border-box;
        }
        
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background-color: rgba(255, 255, 255, 0.8);
        }
        
        #crosshair::before {
            width: 2px;
            height: 10px;
            left: 50%;
            top: -12px;
            transform: translateX(-50%);
        }
        
        #crosshair::after {
            width: 10px;
            height: 2px;
            top: 50%;
            left: -12px;
            transform: translateY(-50%);
        }
        
        #message-display {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 18px;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        #station-name {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 24px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px 15px;
            border-radius: 5px;
        }
        
        #game-over, #game-won {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 36px;
            display: none;
        }
        
        .restart-btn {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 18px;
            background-color: #e74c3c;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            pointer-events: auto;
        }
        
        .restart-btn:hover {
            background-color: #c0392b;
        }
        
        #loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 24px;
        }
        
        #loading-bar {
            width: 300px;
            height: 20px;
            background-color: #333;
            margin-top: 20px;
            border-radius: 10px;
            overflow: hidden;
        }
        
        #loading-progress {
            height: 100%;
            width: 0%;
            background-color: #e74c3c;
            transition: width 0.1s;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <canvas id="hud-canvas"></canvas>
        
        <div id="hud">
            <div id="health-bar">
                <div id="health-fill"></div>
            </div>
            <div id="ammo-display">30/90</div>
            <div id="weapon-display">AK-74</div>
            <div id="crosshair"></div>
            <div id="message-display"></div>
            <div id="station-name">Mayakovskaya</div>
            
            <div id="game-over">
                <h1>GAME OVER</h1>
                <p>You failed to complete your mission</p>
                <button class="restart-btn">TRY AGAIN</button>
            </div>
            
            <div id="game-won">
                <h1>MISSION COMPLETE</h1>
                <p>You've secured the metro station!</p>
                <button class="restart-btn">PLAY AGAIN</button>
            </div>
        </div>
        
        <div id="loading-screen">
            <h2>MOSCOW METRO FPS</h2>
            <p>Loading game assets...</p>
            <div id="loading-bar">
                <div id="loading-progress"></div>
            </div>
        </div>
    </div>

    <script>
        // Инициализация WebGL
        const canvas = document.getElementById('game-canvas');
        const gl = canvas.getContext('webgl');
        if (!gl) {
            alert('WebGL не поддерживается вашим браузером!');
            throw new Error('WebGL не поддерживается');
        }

        // Инициализация 2D контекста для HUD
        const hudCanvas = document.getElementById('hud-canvas');
        const hudCtx = hudCanvas ? hudCanvas.getContext('2d') : null;
        if (!hudCtx) {
            console.error('Не удалось инициализировать 2D контекст для HUD canvas');
        }

        // Элементы HUD
        const healthFill = document.getElementById('health-fill');
        const ammoDisplay = document.getElementById('ammo-display');
        const weaponDisplay = document.getElementById('weapon-display');
        const messageDisplay = document.getElementById('message-display');
        const stationNameDisplay = document.getElementById('station-name');
        const gameOverScreen = document.getElementById('game-over');
        const gameWonScreen = document.getElementById('game-won');
        const loadingScreen = document.getElementById('loading-screen');
        const loadingProgress = document.getElementById('loading-progress');

        // Флаг для отслеживания взаимодействия пользователя
        let userInteracted = false;

        // Fallback текстуры
        const fallbackTextures = {
            wall: createColorTexture(32, 32, '#555'),
            floor: createColorTexture(32, 32, '#333'),
            ceiling: createColorTexture(32, 32, '#222'),
            enemy: createEnemyTexture(32, 32),
            particle: createParticleTexture(16, 16)
        };

        function createColorTexture(width, height, color) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = width;
            tempCanvas.height = height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.fillStyle = color;
            tempCtx.fillRect(0, 0, width, height);
            return tempCanvas;
        }

        function createEnemyTexture(width, height) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = width;
            tempCanvas.height = height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.fillStyle = '#900';
            tempCtx.fillRect(0, 0, width, height);
            tempCtx.fillStyle = '#700';
            tempCtx.fillRect(width/4, height/4, width/2, height/2);
            return tempCanvas;
        }

        function createParticleTexture(width, height) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = width;
            tempCanvas.height = height;
            const tempCtx = tempCanvas.getContext('2d');
            const gradient = tempCtx.createRadialGradient(width/2, height/2, 0, width/2, height/2, width/2);
            gradient.addColorStop(0, 'rgba(255, 255, 0, 1)');
            gradient.addColorStop(1, 'rgba(255, 255, 0, 0)');
            tempCtx.fillStyle = gradient;
            tempCtx.fillRect(0, 0, width, height);
            return tempCanvas;
        }

        const restartBtns = document.querySelectorAll('.restart-btn');
        restartBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                userInteracted = true;
                resetGame();
            });
        });

        // Игровые переменные
        const game = {
            player: {
                x: 0,
                y: 0,
                angle: 0,
                health: 100,
                maxHealth: 100,
                weapons: [
                    {
                        name: "AK-74",
                        ammo: 30,
                        maxAmmo: 30,
                        totalAmmo: 90,
                        fireRate: 100,
                        damage: 25,
                        lastShot: 0,
                        reloadTime: 2000,
                        isReloading: false
                    },
                    {
                        name: "Makarov",
                        ammo: 8,
                        maxAmmo: 8,
                        totalAmmo: 32,
                        fireRate: 500,
                        damage: 15,
                        lastShot: 0,
                        reloadTime: 1500,
                        isReloading: false
                    }
                ],
                currentWeapon: 0,
                isMoving: false,
                moveSpeed: 0.1,
                rotateSpeed: 0.05
            },
            map: {
                width: 16,
                height: 16,
                grid: [],
                stations: [
                    { name: "Mayakovskaya", x: 8, y: 8 },
                    { name: "Kurskaya", x: 4, y: 4 },
                    { name: "Ploschad Revolyutsii", x: 12, y: 4 },
                    { name: "Arbatskaya", x: 4, y: 12 },
                    { name: "Komsomolskaya", x: 12, y: 12 }
                ],
                currentStation: 0
            },
            enemies: [],
            bullets: [],
            particles: [],
            isGameOver: false,
            isGameWon: false,
            lastTime: 0,
            keys: {},
            mouse: {
                x: 0,
                y: 0,
                isDown: false
            },
            assets: {
                textures: {},
                sounds: {}
            },
            assetsLoaded: 0,
            totalAssets: 0,
            frameTimes: [],
            fps: 0,
            zBuffer: []
        };

        // Шейдеры
        const vertexShaderSource = `
            attribute vec2 a_position;
            attribute vec2 a_texCoord;
            varying vec2 v_texCoord;
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
                v_texCoord = a_texCoord;
            }
        `;

        const fragmentShaderSource = `
            precision mediump float;
            varying vec2 v_texCoord;
            uniform sampler2D u_texture;
            uniform float u_wallDist;
            uniform vec4 u_color;
            void main() {
                vec4 texColor = texture2D(u_texture, v_texCoord);
                gl_FragColor = texColor * u_color;
            }
        `;

        const particleVertexShaderSource = `
            attribute vec2 a_position;
            attribute vec2 a_texCoord;
            attribute float a_life;
            varying vec2 v_texCoord;
            varying float v_life;
            uniform float u_pointSize;
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
                gl_PointSize = u_pointSize;
                v_texCoord = a_texCoord;
                v_life = a_life;
            }
        `;

        const particleFragmentShaderSource = `
            precision mediump float;
            varying vec2 v_texCoord;
            varying float v_life;
            uniform sampler2D u_texture;
            void main() {
                vec4 texColor = texture2D(u_texture, gl_PointCoord);
                gl_FragColor = texColor * vec4(1.0, 1.0, 0.0, v_life);
            }
        `;

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Ошибка компиляции шейдера:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            console.log('Шейдер успешно скомпилирован:', type === gl.VERTEX_SHADER ? 'Vertex Shader' : 'Fragment Shader');
            return shader;
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            if (!vertexShader || !fragmentShader) {
                console.error('Один из шейдеров не скомпилирован');
                return null;
            }
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Ошибка линковки программы:', gl.getProgramInfoLog(program));
                return null;
            }
            console.log('Программа WebGL успешно связана');
            return program;
        }

        // Программа для стен, пола, потолка, врагов
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        const program = createProgram(gl, vertexShader, fragmentShader);
        if (!program) {
            throw new Error('Не удалось создать основную программу WebGL');
        }

        // Программа для частиц
        const particleVertexShader = createShader(gl, gl.VERTEX_SHADER, particleVertexShaderSource);
        const particleFragmentShader = createShader(gl, gl.FRAGMENT_SHADER, particleFragmentShaderSource);
        const particleProgram = createProgram(gl, particleVertexShader, particleFragmentShader);
        if (!particleProgram) {
            throw new Error('Не удалось создать программу для частиц');
        }

        // Атрибуты и униформы для основной программы
        gl.useProgram(program);
        const positionLocation = gl.getAttribLocation(program, 'a_position');
        const texCoordLocation = gl.getAttribLocation(program, 'a_texCoord');
        const textureLocation = gl.getUniformLocation(program, 'u_texture');
        const wallDistLocation = gl.getUniformLocation(program, 'u_wallDist');
        const colorLocation = gl.getUniformLocation(program, 'u_color');

        // Атрибуты и униформы для частиц
        gl.useProgram(particleProgram);
        const particlePositionLocation = gl.getAttribLocation(particleProgram, 'a_position');
        const particleTexCoordLocation = gl.getAttribLocation(particleProgram, 'a_texCoord');
        const particleLifeLocation = gl.getAttribLocation(particleProgram, 'a_life');
        const particleTextureLocation = gl.getUniformLocation(particleProgram, 'u_texture');
        const pointSizeLocation = gl.getUniformLocation(particleProgram, 'u_pointSize');

        // Буферы
        const positionBuffer = gl.createBuffer();
        const texCoordBuffer = gl.createBuffer();
        const particlePositionBuffer = gl.createBuffer();
        const particleTexCoordBuffer = gl.createBuffer();
        const particleLifeBuffer = gl.createBuffer();

        function initBuffers() {
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
            gl.enableVertexAttribArray(texCoordLocation);
            gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, particlePositionBuffer);
            gl.enableVertexAttribArray(particlePositionLocation);
            gl.vertexAttribPointer(particlePositionLocation, 2, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, particleTexCoordBuffer);
            gl.enableVertexAttribArray(particleTexCoordLocation);
            gl.vertexAttribPointer(particleTexCoordLocation, 2, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, particleLifeBuffer);
            gl.enableVertexAttribArray(particleLifeLocation);
            gl.vertexAttribPointer(particleLifeLocation, 1, gl.FLOAT, false, 0, 0);
        }

        initBuffers();

        function loadTexture(gl, image) {
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            return texture;
        }

        function spawnEnemies() {
            game.enemies = [];
            const station = game.map.stations[game.map.currentStation];
            
            function spawnSingleEnemy() {
                let x, y, validPosition = false, attempts = 0;
                while (!validPosition && attempts < 50) {
                    attempts++;
                    x = Math.floor(Math.random() * (game.map.width - 4)) + 2;
                    y = Math.floor(Math.random() * (game.map.height - 4)) + 2;
                    if (game.map.grid[y][x] === 0) {
                        const dx = x - game.player.x;
                        const dy = y - game.player.y;
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        if (distance > 2) validPosition = true;
                    }
                }
                if (validPosition) {
                    game.enemies.push({
                        x: x + 0.5,
                        y: y + 0.5,
                        health: 50 + game.map.currentStation * 10,
                        maxHealth: 50 + game.map.currentStation * 10,
                        speed: 0.02 + game.map.currentStation * 0.005,
                        damage: 10 + game.map.currentStation * 2,
                        attackCooldown: 1000,
                        lastAttack: 0,
                        size: 0.4
                    });
                }
            }

            spawnSingleEnemy();
        }

        function generateMap() {
            game.map.grid = [];
            for (let y = 0; y < game.map.height; y++) {
                game.map.grid[y] = [];
                for (let x = 0; x < game.map.width; x++) {
                    if (x === 0 || y === 0 || x === game.map.width - 1 || y === game.map.height - 1) {
                        game.map.grid[y][x] = 1;
                    } else {
                        game.map.grid[y][x] = 0;
                    }
                }
            }
            
            const station = game.map.stations[game.map.currentStation];
            for (let y = station.y - 1; y <= station.y + 1; y++) {
                for (let x = station.x - 1; x <= station.x + 1; x++) {
                    if (x >= 0 && x < game.map.width && y >= 0 && y < game.map.height) {
                        game.map.grid[y][x] = 0;
                    }
                }
            }
            
            let wallCount = 0;
            for (let y = 1; y < game.map.height - 1; y++) {
                for (let x = 1; x < game.map.width - 1; x++) {
                    if (Math.abs(x - station.x) <= 1 && Math.abs(y - station.y) <= 1) continue;
                    if (Math.random() < 0.3) {
                        game.map.grid[y][x] = 1;
                        wallCount++;
                    }
                }
            }
            console.log(`Добавлено ${wallCount} внутренних перегородок`);

            let columnCount = 0;
            for (let i = 0; i < 5; i++) {
                let x, y, validPosition = false, attempts = 0;
                while (!validPosition && attempts < 50) {
                    x = Math.floor(Math.random() * (game.map.width - 4)) + 2;
                    y = Math.floor(Math.random() * (game.map.height - 4)) + 2;
                    if (game.map.grid[y][x] === 0 && 
                        (x + 1 < game.map.width - 1 && y + 1 < game.map.height - 1) &&
                        game.map.grid[y][x+1] === 0 &&
                        game.map.grid[y+1][x] === 0 &&
                        game.map.grid[y+1][x+1] === 0) {
                        validPosition = true;
                    }
                    attempts++;
                }
                if (validPosition) {
                    game.map.grid[y][x] = 1;
                    game.map.grid[y][x+1] = 1;
                    game.map.grid[y+1][x] = 1;
                    game.map.grid[y+1][x+1] = 1;
                    columnCount++;
                }
            }
            console.log(`Добавлено ${columnCount} колонн 2x2`);

            game.player.x = station.x + 0.5;
            game.player.y = station.y + 0.5;
            game.player.angle = Math.random() * Math.PI * 2;
            spawnEnemies();
            stationNameDisplay.textContent = station.name;
        }

        function initGame() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            generateMap();
            setupEventListeners();
            loadAssets();
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth * 0.5;
            canvas.height = window.innerHeight * 0.5;
            canvas.style.width = `${window.innerWidth}px`;
            canvas.style.height = `${window.innerHeight}px`;
            
            if (hudCanvas) {
                hudCanvas.width = window.innerWidth * 0.5;
                hudCanvas.height = window.innerHeight * 0.5;
                hudCanvas.style.width = `${window.innerWidth}px`;
                hudCanvas.style.height = `${window.innerHeight}px`;
            }

            game.zBuffer = new Array(canvas.width).fill(Infinity);
            gl.viewport(0, 0, canvas.width, canvas.height);
        }

        function setupEventListeners() {
            window.addEventListener('keydown', (e) => {
                game.keys[e.key.toLowerCase()] = true;
                if (e.key === '1') { game.player.currentWeapon = 0; updateWeaponDisplay(); }
                else if (e.key === '2') { game.player.currentWeapon = 1; updateWeaponDisplay(); }
                else if (e.key.toLowerCase() === ' discord.comr') reloadWeapon();
            });
            window.addEventListener('keyup', (e) => {
                game.keys[e.key.toLowerCase()] = false;
            });
            canvas.addEventListener('mousemove', (e) => {
                if (document.pointerLockElement === canvas) {
                    game.player.angle += e.movementX * 0.002;
                }
            });
            canvas.addEventListener('mousedown', () => {
                userInteracted = true;
                canvas.requestPointerLock();
            });
            document.addEventListener('pointerlockchange', () => {
                game.mouse.isDown = document.pointerLockElement === canvas;
            });
            canvas.addEventListener('click', shoot);
        }

        function loadAssets() {
             const textures = [
                { name: 'wall', url: './assets/textures/wall.png' },
                { name: 'floor', url: './assets/textures/floor.png' },
                { name: 'ceiling', url: './assets/textures/ceiling.png' },
                { name: 'enemy', url: './assets/textures/enemy.png' }
            ];
            const sounds = [
                { name: 'shot', url: '/metrofps/assets/sfx/gun-shot-1680.mp3' },
                { name: 'reload', url: '/metrofps/assets/sfx/gun-reload-1910.mp3' },
                { name: 'hit', url: '/metrofps/assets/sfx/arrow-whoosh-1491.mp3' },
                { name: 'enemyDeath', url: '/metrofps/assets/sfx/ominous-drums-227.mp3' },
                { name: 'playerHurt', url: '/metrofps/assets/sfx/player-jumping-1929.mp3' }
            ];
            
            game.totalAssets = textures.length + sounds.length;
            
            textures.forEach(texture => {
                const img = new Image();
                img.onload = () => {
                    game.assets.textures[texture.name] = loadTexture(gl, img);
                    console.log(`Текстура ${texture.name} загружена`);
                    assetLoaded();
                };
                img.onerror = () => {
                    console.warn(`Ошибка загрузки текстуры ${texture.name}, используем запасную`);
                    game.assets.textures[texture.name] = loadTexture(gl, fallbackTextures[texture.name]);
                    assetLoaded();
                };
                img.src = texture.url;
            });
            
            sounds.forEach(sound => {
                const audio = new Audio();
                audio.oncanplaythrough = () => {
                    game.assets.sounds[sound.name] = audio;
                    console.log(`Звук ${sound.name} загружен`);
                    assetLoaded();
                };
                audio.onerror = () => {
                    console.warn(`Ошибка загрузки звука ${sound.name}`);
                    assetLoaded();
                };
                audio.src = sound.url;
            });
            
            function assetLoaded() {
                game.assetsLoaded++;
                const progress = Math.floor((game.assetsLoaded / game.totalAssets) * 100);
                loadingProgress.style.width = `${isNaN(progress) ? 0 : progress}%`;
                if (game.assetsLoaded === game.totalAssets) {
                    setTimeout(() => {
                        loadingScreen.style.display = 'none';
                        updateHealthDisplay();
                        updateAmmoDisplay();
                        updateWeaponDisplay();
                        requestAnimationFrame(gameLoop);
                    }, 500);
                }
            }
            
            setTimeout(() => {
                if (game.assetsLoaded < game.totalAssets) {
                    for (const texture in fallbackTextures) {
                        if (!game.assets.textures[texture]) {
                            game.assets.textures[texture] = loadTexture(gl, fallbackTextures[texture]);
                            console.log(`Использована запасная текстура для ${texture}`);
                        }
                    }
                    loadingScreen.style.display = 'none';
                    updateHealthDisplay();
                    updateAmmoDisplay();
                    updateWeaponDisplay();
                    requestAnimationFrame(gameLoop);
                }
            }, 5000);
        }

        function gameLoop(timestamp) {
            if (game.isGameOver || game.isGameWon) return;
            const deltaTime = timestamp - game.lastTime || 16;
            game.lastTime = timestamp;
            
            game.frameTimes.push(deltaTime);
            if (game.frameTimes.length > 60) game.frameTimes.shift();
            const avgFrameTime = game.frameTimes.reduce((a, b) => a + b, 0) / game.frameTimes.length;
            game.fps = Math.round(1000 / avgFrameTime);
            
            update(Math.min(deltaTime, 33));
            render();
            requestAnimationFrame(gameLoop);
        }

        function update(deltaTime) {
            const moveSpeed = game.player.moveSpeed * (deltaTime / 16);
            const rotateSpeed = game.player.rotateSpeed * (deltaTime / 16);

            if (game.keys['w'] || game.keys['arrowup']) movePlayer(moveSpeed);
            if (game.keys['s'] || game.keys['arrowdown']) movePlayer(-moveSpeed * 0.7);
            if (game.keys['a'] || game.keys['arrowleft']) strafePlayer(-moveSpeed);
            if (game.keys['d'] || game.keys['arrowright']) strafePlayer(moveSpeed);
            
            updateBullets(deltaTime);
            updateEnemies(deltaTime);
            updateParticles(deltaTime);
        }

        function movePlayer(speed) {
            const newX = game.player.x + Math.cos(game.player.angle) * speed;
            const newY = game.player.y + Math.sin(game.player.angle) * speed;
            if (canMoveTo(newX, game.player.y)) game.player.x = newX;
            if (canMoveTo(game.player.x, newY)) game.player.y = newY;
        }

        function strafePlayer(speed) {
            const angle = game.player.angle + Math.PI/2;
            const newX = game.player.x + Math.cos(angle) * speed;
            const newY = game.player.y + Math.sin(angle) * speed;
            if (canMoveTo(newX, game.player.y)) game.player.x = newX;
            if (canMoveTo(game.player.x, newY)) game.player.y = newY;
        }

        function canMoveTo(x, y) {
            if (x < 0.3 || x >= game.map.width - 0.3 || y < 0.3 || y >= game.map.height - 0.3) return false;
            
            const mapX = Math.floor(x);
            const mapY = Math.floor(y);
            
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const checkX = mapX + dx;
                    const checkY = mapY + dy;
                    if (checkX >= 0 && checkX < game.map.width && checkY >= 0 && checkY < game.map.height) {
                        if (game.map.grid[checkY][checkX] === 1) {
                            const wallX = checkX + (dx > 0 ? 0 : 1);
                            const wallY = checkY + (dy > 0 ? 0 : 1);
                            const distX = x - wallX;
                            const distY = y - wallY;
                            if (Math.abs(distX) < 0.3 && Math.abs(distY) < 0.3) return false;
                        }
                    }
                }
            }
            
            for (const enemy of game.enemies) {
                const dx = x - enemy.x;
                const dy = y - enemy.y;
                const distance = Math.sqrt(dx*dx + dy*dy);
                if (distance < 0.5) return false;
            }
            return true;
        }

        let lastEnemyUpdate = 0;
        function updateEnemies(deltaTime) {
            const now = Date.now();
            if (now - lastEnemyUpdate < 100) return;
            lastEnemyUpdate = now;

            for (const enemy of game.enemies) {
                const dx = game.player.x - enemy.x;
                const dy = game.player.y - enemy.y;
                const distance = Math.sqrt(dx*dx + dy*dy);
                
                if (distance > 0.5) {
                    const angle = Math.atan2(dy, dx);
                    const newX = enemy.x + Math.cos(angle) * enemy.speed * (deltaTime / 16);
                    const newY = enemy.y + Math.sin(angle) * enemy.speed * (deltaTime / 16);
                    
                    const mapX = Math.floor(newX);
                    const mapY = Math.floor(newY);
                    if (mapX >= 0 && mapX < game.map.width && mapY >= 0 && mapY < game.map.height && 
                        game.map.grid[mapY][mapX] === 0) {
                        enemy.x = newX;
                        enemy.y = newY;
                    }
                }
                
                if (distance < 2 && now - enemy.lastAttack > enemy.attackCooldown) {
                    enemy.lastAttack = now;
                    game.player.health -= enemy.damage;
                    if (userInteracted && game.assets.sounds.playerHurt) {
                        const hurtSound = game.assets.sounds.playerHurt.cloneNode();
                        hurtSound.play().catch(e => console.warn("Ошибка воспроизведения звука:", e));
                    }
                    updateHealthDisplay();
                    if (game.player.health <= 0) gameOver();
                }
            }
        }

        function updateBullets(deltaTime) {
            for (let i = game.bullets.length - 1; i >= 0; i--) {
                const bullet = game.bullets[i];
                bullet.x += Math.cos(bullet.angle) * bullet.speed * (deltaTime / 16);
                bullet.y += Math.sin(bullet.angle) * bullet.speed * (deltaTime / 16);
                
                const mapX = Math.floor(bullet.x);
                const mapY = Math.floor(bullet.y);
                
                if (mapX < 0 || mapX >= game.map.width || mapY < 0 || mapY >= game.map.height || 
                    game.map.grid[mapY][mapX] === 1) {
                    createParticle(bullet.x, bullet.y, 5, [1, 1, 0, 1], 20);
                    if (userInteracted && game.assets.sounds.hit) {
                        const hitSound = game.assets.sounds.hit.cloneNode();
                        hitSound.volume = 0.3;
                        hitSound.play().catch(e => console.warn("Ошибка воспроизведения звука:", e));
                    }
                    game.bullets.splice(i, 1);
                    continue;
                }
                
                for (let j = game.enemies.length - 1; j >= 0; j--) {
                    const enemy = game.enemies[j];
                    const dx = bullet.x - enemy.x;
                    const dy = bullet.y - enemy.y;
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    if (distance < enemy.size) {
                        enemy.health -= bullet.damage;
                        createParticle(bullet.x, bullet.y, 10, [1, 0, 0, 1], 30);
                        if (userInteracted && game.assets.sounds.hit) {
                            const hitSound = game.assets.sounds.hit.cloneNode();
                            hitSound.volume = 0.5;
                            hitSound.play().catch(e => console.warn("Ошибка воспроизведения звука:", e));
                        }
                        game.bullets.splice(i, 1);
                        
                        if (enemy.health <= 0) {
                            if (userInteracted && game.assets.sounds.enemyDeath) {
                                const deathSound = game.assets.sounds.enemyDeath.cloneNode();
                                deathSound.volume = 0.7;
                                deathSound.play().catch(e => console.warn("Ошибка воспроизведения звука:", e));
                            }
                            game.enemies.splice(j, 1);
                            if (game.enemies.length === 0) nextStation();
                        }
                        break;
                    }
                }
            }
        }

        function updateParticles(deltaTime) {
            for (let i = game.particles.length - 1; i >= 0; i--) {
                const particle = game.particles[i];
                particle.x += Math.cos(particle.angle) * particle.speed * (deltaTime / 16);
                particle.y += Math.sin(particle.angle) * particle.speed * (deltaTime / 16);
                particle.life -= deltaTime / particle.maxLife;
                if (particle.life <= 0) game.particles.splice(i, 1);
            }
            if (game.particles.length > 50) game.particles.splice(0, game.particles.length - 50);
        }

        function createParticle(x, y, count, color, maxLife) {
            for (let i = 0; i < count; i++) {
                game.particles.push({
                    x: x,
                    y: y,
                    angle: Math.random() * Math.PI * 2,
                    speed: Math.random() * 0.05 + 0.02,
                    life: 1.0,
                    maxLife: maxLife,
                    color: color
                });
            }
        }

        function shoot() {
            const weapon = game.player.weapons[game.player.currentWeapon];
            const now = Date.now();
            
            if (weapon.ammo <= 0) {
                reloadWeapon();
                return;
            }
            
            if (now - weapon.lastShot < weapon.fireRate || weapon.isReloading) return;
            
            weapon.lastShot = now;
            weapon.ammo--;
            
            if (userInteracted && game.assets.sounds.shot) {
                const shotSound = game.assets.sounds.shot.cloneNode();
                shotSound.play().catch(e => console.warn("Ошибка воспроизведения звука:", e));
            }
            
            game.bullets.push({
                x: game.player.x,
                y: game.player.y,
                angle: game.player.angle,
                speed: 0.3,
                damage: weapon.damage
            });
            
            createParticle(
                game.player.x + Math.cos(game.player.angle) * 0.5,
                game.player.y + Math.sin(game.player.angle) * 0.5,
                2, [1, 1, 0, 1], 10
            );
            
            updateAmmoDisplay();
        }

        function reloadWeapon() {
            const weapon = game.player.weapons[game.player.currentWeapon];
            if (weapon.isReloading || weapon.ammo === weapon.maxAmmo || weapon.totalAmmo <= 0) return;
            
            weapon.isReloading = true;
            if (userInteracted && game.assets.sounds.reload) {
                const reloadSound = game.assets.sounds.reload.cloneNode();
                reloadSound.play().catch(e => console.warn("Ошибка воспроизведения звука:", e));
            }
            showMessage(`Reloading ${weapon.name}...`);
            
            setTimeout(() => {
                const ammoNeeded = weapon.maxAmmo - weapon.ammo;
                const ammoAvailable = Math.min(ammoNeeded, weapon.totalAmmo);
                weapon.ammo += ammoAvailable;
                weapon.totalAmmo -= ammoAvailable;
                weapon.isReloading = false;
                updateAmmoDisplay();
                updateWeaponDisplay();
                showMessage(`${weapon.name} reloaded`);
            }, weapon.reloadTime);
        }

        function updateHealthDisplay() {
            const healthPercent = (game.player.health / game.player.maxHealth) * 100;
            healthFill.style.width = `${isNaN(healthPercent) ? 0 : healthPercent}%`;
            if (healthPercent > 60) healthFill.style.backgroundColor = '#2ecc71';
            else if (healthPercent > 30) healthFill.style.backgroundColor = '#f39c12';
            else healthFill.style.backgroundColor = '#e74c3c';
        }

        function updateAmmoDisplay() {
            const weapon = game.player.weapons[game.player.currentWeapon];
            ammoDisplay.textContent = `${weapon.ammo}/${weapon.totalAmmo}`;
        }

        function updateWeaponDisplay() {
            const weapon = game.player.weapons[game.player.currentWeapon];
            weaponDisplay.textContent = weapon.name;
        }

        function showMessage(text) {
            messageDisplay.textContent = text;
            messageDisplay.style.opacity = 1;
            setTimeout(() => messageDisplay.style.opacity = 0, 3000);
        }

        function gameOver() {
            game.isGameOver = true;
            gameOverScreen.style.display = 'flex';
        }

        function nextStation() {
            game.map.currentStation++;
            if (game.map.currentStation >= game.map.stations.length) {
                game.isGameWon = true;
                gameWonScreen.style.display = 'flex';
            } else {
                showMessage(`Moving to ${game.map.stations[game.map.currentStation].name} station`);
                game.player.health = game.player.maxHealth;
                updateHealthDisplay();
                setTimeout(generateMap, 2000);
            }
        }

        function resetGame() {
            game.isGameOver = false;
            game.isGameWon = false;
            gameOverScreen.style.display = 'none';
            gameWonScreen.style.display = 'none';
            game.player.health = game.player.maxHealth;
            game.player.weapons[0].ammo = 30;
            game.player.weapons[0].totalAmmo = 90;
            game.player.weapons[1].ammo = 8;
            game.player.weapons[1].totalAmmo = 32;
            game.player.currentWeapon = 0;
            game.map.currentStation = 0;
            updateHealthDisplay();
            updateAmmoDisplay();
            updateWeaponDisplay();
            generateMap();
            requestAnimationFrame(gameLoop);
        }

        function drawQuad(x1, y1, x2, y2, texX1, texY1, texX2, texY2, texture, wallDist, color) {
            if (!texture) {
                console.warn('Текстура не загружена, используется запасная текстура стены');
                texture = fallbackTextures.wall;
            }
            gl.useProgram(program);
            const positions = new Float32Array([
                x1, y1,
                x2, y1,
                x1, y2,
                x2, y2
            ]);

            const texCoords = new Float32Array([
                texX1, texY1,
                texX2, texY1,
                texX1, texY2,
                texX2, texY2
            ]);

            console.log('Координаты вершин:', { x1, y1, x2, y2 });
            console.log('Текстурные координаты:', { texX1, texY1, texX2, texY2 });
            console.log('wallDist:', wallDist);

            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

            gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, texCoords, gl.STATIC_DRAW);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.uniform1i(textureLocation, 0);
            gl.uniform1f(wallDistLocation, wallDist);
            gl.uniform4fv(colorLocation, color);

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            console.log('Вызван drawQuad для рендеринга');
        }

        function draw3DView() {
            const fov = Math.PI / 3;
            const halfFov = fov / 2;
            const rayStep = 16;
            const numRays = Math.floor(canvas.width / rayStep);
            const rayAngleStep = fov / numRays;

            for (let column = 0; column < canvas.width; column += rayStep) {
                const i = Math.floor(column / rayStep);
                const rayAngle = game.player.angle - halfFov + i * rayAngleStep;
                drawFloorAndCeiling(column, rayAngle, rayStep);
            }

            for (let i = 0; i < numRays; i++) {
                const rayAngle = game.player.angle - halfFov + i * rayAngleStep;
                castRay(rayAngle, i * rayStep, rayStep);
            }

            drawEnemies();
        }

        function castRay(angle, column, rayStep) {
            let rayX = game.player.x, rayY = game.player.y;
            const rayDirX = Math.cos(angle), rayDirY = Math.sin(angle);
            let sideDistX, sideDistY;
            const deltaDistX = Math.abs(1 / rayDirX) || 1e10, deltaDistY = Math.abs(1 / rayDirY) || 1e10;
            let stepX, stepY, mapX = Math.floor(rayX), mapY = Math.floor(rayY);
            
            if (rayDirX < 0) { stepX = -1; sideDistX = (game.player.x - mapX) * deltaDistX; }
            else { stepX = 1; sideDistX = (mapX + 1.0 - game.player.x) * deltaDistX; }
            if (rayDirY < 0) { stepY = -1; sideDistY = (game.player.y - mapY) * deltaDistY; }
            else { stepY = 1; sideDistY = (mapY + 1.0 - game.player.y) * deltaDistY; }
            
            let hit = false, side, wallDist;
            while (!hit) {
                if (sideDistX < sideDistY) { sideDistX += deltaDistX; mapX += stepX; side = 0; }
                else { sideDistY += deltaDistY; mapY += stepY; side = 1; }
                if (mapX < 0 || mapX >= game.map.width || mapY < 0 || mapY >= game.map.height) { 
                    hit = true; 
                    wallDist = 100; 
                } else if (game.map.grid[mapY][mapX] === 1) {
                    hit = true;
                    wallDist = side === 0 ? (mapX - game.player.x + (1 - stepX) / 2) / rayDirX : 
                                          (mapY - game.player.y + (1 - stepY) / 2) / rayDirY;
                }
            }
            
            if (isNaN(wallDist) || wallDist <= 0) wallDist = 100;
            const lineHeight = canvas.height / (wallDist + 0.0001);
            let drawStart = -lineHeight / 2 + canvas.height / 2; if (drawStart < 0) drawStart = 0;
            let drawEnd = lineHeight / 2 + canvas.height / 2; if (drawEnd >= canvas.height) drawEnd = canvas.height - 1;

            let wallX = side === 0 ? game.player.y + wallDist * rayDirY : game.player.x + wallDist * rayDirX;
            wallX -= Math.floor(wallX);

            const texX = wallX;

            const x1 = (column / canvas.width) * 2 - 1;
            const x2 = ((column + rayStep) / canvas.width) * 2 - 1;
            const y1 = (drawStart / canvas.height) * 2 - 1;
            const y2 = (drawEnd / canvas.height) * 2 - 1;

            drawQuad(x1, y1, x2, y2, texX, 0, texX + (1 / 32), 1, game.assets.textures.wall || fallbackTextures.wall, wallDist, [1, 1, 1, 1]);

            for (let x = column; x < column + rayStep; x++) {
                if (x >= 0 && x < game.zBuffer.length) game.zBuffer[x] = wallDist;
            }
        }

        function drawFloorAndCeiling(column, angle, rayStep) {
            const horizon = canvas.height / 2;
            const x1 = (column / canvas.width) * 2 - 1;
            const x2 = ((column + rayStep) / canvas.width) * 2 - 1;

            for (let y = horizon; y < canvas.height; y += 32) {
                const currentDist = canvas.height / (2.0 * y - canvas.height);
                const weight = currentDist / 100;
                const currentFloorX = weight * (game.player.x + Math.cos(angle) * 100) + (1.0 - weight) * game.player.x;
                const currentFloorY = weight * (game.player.y + Math.sin(angle) * 100) + (1.0 - weight) * game.player.y;
                const floorTexX = currentFloorX * 32 % 32 / 32;
                const floorTexY = currentFloorY * 32 % 32 / 32;

                const y1 = (y / canvas.height) * 2 - 1;
                const y2 = ((y + 32) / canvas.height) * 2 - 1;

                drawQuad(x1, y1, x2, y2, floorTexX, floorTexY, floorTexX + (1 / 32), floorTexY + (1 / 32), game.assets.textures.floor || fallbackTextures.floor, currentDist, [1, 1, 1, 1]);
            }

            for (let y = 0; y < horizon; y += 32) {
                const currentDist = canvas.height / (canvas.height - 2.0 * y);
                const weight = currentDist / 100;
                const currentCeilingX = weight * (game.player.x + Math.cos(angle) * 100) + (1.0 - weight) * game.player.x;
                const currentCeilingY = weight * (game.player.y + Math.sin(angle) * 100) + (1.0 - weight) * game.player.y;
                const ceilingTexX = currentCeilingX * 32 % 32 / 32;
                const ceilingTexY = currentCeilingY * 32 % 32 / 32;

                const y1 = (y / canvas.height) * 2 - 1;
                const y2 = ((y + 32) / canvas.height) * 2 - 1;

                drawQuad(x1, y1, x2, y2, ceilingTexX, ceilingTexY, ceilingTexX + (1 / 32), ceilingTexY + (1 / 32), game.assets.textures.ceiling || fallbackTextures.ceiling, currentDist, [1, 1, 1, 1]);
            }
        }

        function drawEnemies() {
            const sortedEnemies = [...game.enemies].sort((a, b) => {
                const distA = Math.sqrt(Math.pow(a.x - game.player.x, 2) + Math.pow(a.y - game.player.y, 2));
                const distB = Math.sqrt(Math.pow(b.x - game.player.x, 2) + Math.pow(b.y - game.player.y, 2));
                return distB - distA;
            });

            for (const enemy of sortedEnemies) {
                const dx = enemy.x - game.player.x;
                const dy = enemy.y - game.player.y;
                const distance = Math.sqrt(dx*dx + dy*dy);
                let angle = Math.atan2(dy, dx) - game.player.angle;
                while (angle < -Math.PI) angle += 2*Math.PI;
                while (angle > Math.PI) angle -= 2*Math.PI;
                
                const fov = Math.PI / 3;
                if (Math.abs(angle) > fov / 2) continue;
                
                const enemyHeight = canvas.height / distance * enemy.size * 2;
                const enemyWidth = enemyHeight;
                const screenX = (angle + fov/2) / fov * canvas.width - enemyWidth/2;
                const screenY = canvas.height/2 - enemyHeight/2;
                
                const centerX = Math.floor(screenX + enemyWidth/2);
                if (centerX >= 0 && centerX < game.zBuffer.length && distance >= game.zBuffer[centerX]) continue;
                
                const x1 = (screenX / canvas.width) * 2 - 1;
                const x2 = ((screenX + enemyWidth) / canvas.width) * 2 - 1;
                const y1 = (screenY / canvas.height) * 2 - 1;
                const y2 = ((screenY + enemyHeight) / canvas.height) * 2 - 1;

                drawQuad(x1, y1, x2, y2, 0, 0, 1, 1, game.assets.textures.enemy || fallbackTextures.enemy, distance, [1, 1, 1, 1]);
            }
        }

        function drawParticles() {
            console.log('Рендеринг частиц отключен для оптимизации');
            return;
        }

        function projectToScreenX(x, y) {
            const dx = x - game.player.x;
            const dy = y - game.player.y;
            const distance = Math.sqrt(dx*dx + dy*dy);
            let angle = Math.atan2(dy, dx) - game.player.angle;
            while (angle < -Math.PI) angle += 2*Math.PI;
            while (angle > Math.PI) angle -= 2*Math.PI;
            
            const fov = Math.PI / 3;
            if (Math.abs(angle) > fov / 2) return -2;
            
            const screenX = (angle + fov/2) / fov * canvas.width;
            return (screenX / canvas.width) * 2 - 1;
        }

        function projectToScreenY(x, y) {
            const distance = Math.sqrt(Math.pow(x - game.player.x, 2) + Math.pow(y - game.player.y, 2));
            const screenY = canvas.height / 2 - (canvas.height / distance) / 2;
            return (screenY / canvas.height) * 2 - 1;
        }

        function drawHUD() {
            if (!hudCtx) return;
            hudCtx.clearRect(0, 0, hudCanvas.width, hudCanvas.height);
            const weapon = game.player.weapons[game.player.currentWeapon];
            const now = Date.now();
            const recoil = Math.min((now - weapon.lastShot) / 100, 1.0) * 0.1;
            hudCtx.fillStyle = '#555';
            hudCtx.fillRect(hudCanvas.width * 0.4, hudCanvas.height * 0.7 - hudCanvas.height * recoil, hudCanvas.width * 0.2, hudCanvas.height * 0.2);
            
            if (weapon.isReloading) {
                const reloadProgress = (now - (weapon.lastShot + weapon.fireRate)) / weapon.reloadTime;
                hudCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                hudCtx.fillRect(hudCanvas.width * 0.3, hudCanvas.height * 0.8, hudCanvas.width * 0.4, 10);
                hudCtx.fillStyle = '#f39c12';
                hudCtx.fillRect(hudCanvas.width * 0.3, hudCanvas.height * 0.8, hudCanvas.width * 0.4 * reloadProgress, 10);
            }

            hudCtx.fillStyle = 'white';
            hudCtx.font = '16px Arial';
            hudCtx.fillText(`FPS: ${game.fps}`, 10, 20);
        }

        function render() {
            console.log('Начало рендеринга кадра');
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);
            game.zBuffer.fill(Infinity);
            console.log('Вызывается draw3DView');
            draw3DView();
            console.log('Вызывается drawParticles');
            drawParticles();
            console.log('Вызывается drawHUD');
            drawHUD();
            console.log('Конец рендеринга кадра');
        }

        initGame();
    </script>
</body>
</html>
