<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Moscow Metro FPS</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Arial', sans-serif;
        }
        
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #game-canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            color: white;
            font-family: 'Arial', sans-serif;
        }
        
        #health-bar {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 200px;
            height: 30px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 2px solid #333;
            border-radius: 5px;
            overflow: hidden;
        }
        
        #health-fill {
            height: 100%;
            width: 100%;
            background-color: #e74c3c;
            transition: width 0.3s;
        }
        
        #ammo-display {
            position: absolute;
            bottom: 20px;
            right: 20px;
            font-size: 24px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px 15px;
            border-radius: 5px;
        }
        
        #weapon-display {
            position: absolute;
            bottom: 70px;
            right: 20px;
            font-size: 18px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 8px 12px;
            border-radius: 5px;
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            box-sizing: border-box;
        }
        
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background-color: rgba(255, 255, 255, 0.8);
        }
        
        #crosshair::before {
            width: 2px;
            height: 10px;
            left: 50%;
            top: -12px;
            transform: translateX(-50%);
        }
        
        #crosshair::after {
            width: 10px;
            height: 2px;
            top: 50%;
            left: -12px;
            transform: translateY(-50%);
        }
        
        #message-display {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 18px;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        #station-name {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 24px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px 15px;
            border-radius: 5px;
        }
        
        #game-over, #game-won {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 36px;
            display: none;
        }
        
        .restart-btn {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 18px;
            background-color: #e74c3c;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            pointer-events: auto;
        }
        
        .restart-btn:hover {
            background-color: #c0392b;
        }
        
        #loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 24px;
        }
        
        #loading-bar {
            width: 300px;
            height: 20px;
            background-color: #333;
            margin-top: 20px;
            border-radius: 10px;
            overflow: hidden;
        }
        
        #loading-progress {
            height: 100%;
            width: 0%;
            background-color: #e74c3c;
            transition: width 0.1s;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        
        <div id="hud">
            <div id="health-bar">
                <div id="health-fill"></div>
            </div>
            <div id="ammo-display">30/90</div>
            <div id="weapon-display">AK-74</div>
            <div id="crosshair"></div>
            <div id="message-display"></div>
            <div id="station-name">Mayakovskaya</div>
            
            <div id="game-over">
                <h1>GAME OVER</h1>
                <p>You failed to complete your mission</p>
                <button class="restart-btn">TRY AGAIN</button>
            </div>
            
            <div id="game-won">
                <h1>MISSION COMPLETE</h1>
                <p>You've secured the metro station!</p>
                <button class="restart-btn">PLAY AGAIN</button>
            </div>
        </div>
        
        <div id="loading-screen">
            <h2>MOSCOW METRO FPS</h2>
            <p>Loading game assets...</p>
            <div id="loading-bar">
                <div id="loading-progress"></div>
            </div>
        </div>
    </div>

    <script>
        // Game variables
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const healthFill = document.getElementById('health-fill');
        const ammoDisplay = document.getElementById('ammo-display');
        const weaponDisplay = document.getElementById('weapon-display');
        const messageDisplay = document.getElementById('message-display');
        const stationNameDisplay = document.getElementById('station-name');
        const gameOverScreen = document.getElementById('game-over');
        const gameWonScreen = document.getElementById('game-won');
        const loadingScreen = document.getElementById('loading-screen');
        const loadingProgress = document.getElementById('loading-progress');
        
        // Fallback textures
        const fallbackTextures = {
            wall: createColorTexture(64, 64, '#555'),
            floor: createColorTexture(64, 64, '#333'),
            ceiling: createColorTexture(64, 64, '#222'),
            enemy: createEnemyTexture(64, 64)
        };
        
        function createColorTexture(width, height, color) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = width;
            tempCanvas.height = height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.fillStyle = color;
            tempCtx.fillRect(0, 0, width, height);
            return tempCanvas;
        }
        
        function createEnemyTexture(width, height) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = width;
            tempCanvas.height = height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.fillStyle = '#900';
            tempCtx.fillRect(0, 0, width, height);
            tempCtx.fillStyle = '#700';
            tempCtx.fillRect(width/4, height/4, width/2, height/2);
            return tempCanvas;
        }
        
        const restartBtns = document.querySelectorAll('.restart-btn');
        restartBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                resetGame();
            });
        });
        
        const game = {
            player: {
                x: 0,
                y: 0,
                angle: 0,
                health: 100,
                maxHealth: 100,
                weapons: [
                    {
                        name: "AK-74",
                        ammo: 30,
                        maxAmmo: 30,
                        totalAmmo: 90,
                        fireRate: 100,
                        damage: 25,
                        lastShot: 0,
                        reloadTime: 2000,
                        isReloading: false
                    },
                    {
                        name: "Makarov",
                        ammo: 8,
                        maxAmmo: 8,
                        totalAmmo: 32,
                        fireRate: 500,
                        damage: 15,
                        lastShot: 0,
                        reloadTime: 1500,
                        isReloading: false
                    }
                ],
                currentWeapon: 0,
                isMoving: false,
                moveSpeed: 0.1,
                rotateSpeed: 0.05
            },
            map: {
                width: 32,
                height: 32,
                grid: [],
                stations: [
                    { name: "Mayakovskaya", x: 5, y: 5 },
                    { name: "Kurskaya", x: 15, y: 5 },
                    { name: "Ploschad Revolyutsii", x: 25, y: 5 },
                    { name: "Arbatskaya", x: 5, y: 15 },
                    { name: "Komsomolskaya", x: 15, y: 15 },
                    { name: "Novoslobodskaya", x: 25, y: 15 },
                    { name: "Kievskaya", x: 5, y: 25 },
                    { name: "Belorusskaya", x: 15, y: 25 },
                    { name: "Park Pobedy", x: 25, y: 25 }
                ],
                currentStation: 0
            },
            enemies: [],
            bullets: [],
            particles: [],
            isGameOver: false,
            isGameWon: false,
            lastTime: 0,
            keys: {},
            mouse: {
                x: 0,
                y: 0,
                isDown: false
            },
            assets: {
                textures: {},
                sounds: {}
            },
            assetsLoaded: 0,
            totalAssets: 0,
            frameTimes: [],
            fps: 0,
            zBuffer: []  // Буфер глубины для рендеринга
        };
        
        function initGame() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            generateMap();
            setupEventListeners();
            loadAssets();
        }
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            game.zBuffer = new Array(canvas.width).fill(Infinity);
        }
        
        function generateMap() {
            game.map.grid = [];
            for (let y = 0; y < game.map.height; y++) {
                game.map.grid[y] = [];
                for (let x = 0; x < game.map.width; x++) {
                    if (x === 0 || y === 0 || x === game.map.width - 1 || y === game.map.height - 1) {
                        game.map.grid[y][x] = 1;
                    } else {
                        game.map.grid[y][x] = 0;
                    }
                }
            }
            
            const station = game.map.stations[game.map.currentStation];
            for (let y = station.y - 1; y <= station.y + 1; y++) {
                for (let x = station.x - 1; x <= station.x + 1; x++) {
                    if (x >= 0 && x < game.map.width && y >= 0 && y < game.map.height) {
                        game.map.grid[y][x] = 0;
                    }
                }
            }
            
            for (let y = station.y - 3; y <= station.y + 3; y++) {
                for (let x = station.x - 3; x <= station.x + 3; x++) {
                    if (x >= 0 && x < game.map.width && y >= 0 && y < game.map.height) {
                        if (Math.abs(x - station.x) <= 1 && Math.abs(y - station.y) <= 1) continue;
                        if (Math.random() < 0.4) {
                            game.map.grid[y][x] = 1;
                        }
                    }
                }
            }
            
            for (let i = 0; i < 5; i++) {
                const x = Math.floor(Math.random() * (game.map.width - 4)) + 2;
                const y = Math.floor(Math.random() * (game.map.height - 4)) + 2;
                if (Math.abs(x - station.x) > 1 || Math.abs(y - station.y) > 1) {
                    game.map.grid[y][x] = 1;
                    if (x + 1 < game.map.width - 1 && y + 1 < game.map.height - 1) {
                        game.map.grid[y][x+1] = 1;
                        game.map.grid[y+1][x] = 1;
                        game.map.grid[y+1][x+1] = 1;
                    }
                }
            }
            
            game.player.x = station.x + 0.5;
            game.player.y = station.y + 0.5;
            game.player.angle = Math.random() * Math.PI * 2;
            spawnEnemies();
            stationNameDisplay.textContent = station.name;
        }
        
        function spawnEnemies() {
            game.enemies = [];
            const station = game.map.stations[game.map.currentStation];
            const enemyCount = 5 + game.map.currentStation * 2;
            
            for (let i = 0; i < enemyCount; i++) {
                let x, y, validPosition = false, attempts = 0;
                while (!validPosition && attempts < 50) {
                    attempts++;
                    x = Math.floor(Math.random() * (game.map.width - 4)) + 2;
                    y = Math.floor(Math.random() * (game.map.height - 4)) + 2;
                    if (game.map.grid[y][x] === 0) {
                        const dx = x - game.player.x;
                        const dy = y - game.player.y;
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        if (distance > 5) validPosition = true;
                    }
                }
                if (validPosition) {
                    game.enemies.push({
                        x: x + 0.5,
                        y: y + 0.5,
                        health: 50 + game.map.currentStation * 10,
                        maxHealth: 50 + game.map.currentStation * 10,
                        speed: 0.02 + game.map.currentStation * 0.005,
                        damage: 10 + game.map.currentStation * 2,
                        attackCooldown: 1000,
                        lastAttack: 0,
                        size: 0.4
                    });
                }
            }
        }
        
        function setupEventListeners() {
            window.addEventListener('keydown', (e) => {
                game.keys[e.key.toLowerCase()] = true;
                if (e.key === '1') { game.player.currentWeapon = 0; updateWeaponDisplay(); }
                else if (e.key === '2') { game.player.currentWeapon = 1; updateWeaponDisplay(); }
                else if (e.key.toLowerCase() === 'r') reloadWeapon();
            });
            window.addEventListener('keyup', (e) => {
                game.keys[e.key.toLowerCase()] = false;
            });
            canvas.addEventListener('mousemove', (e) => {
                if (document.pointerLockElement === canvas) {
                    game.player.angle += e.movementX * 0.002;
                }
            });
            canvas.addEventListener('mousedown', () => {
                canvas.requestPointerLock();
            });
            document.addEventListener('pointerlockchange', () => {
                game.mouse.isDown = document.pointerLockElement === canvas;
            });
            canvas.addEventListener('click', shoot);
        }
        
        function loadAssets() {
            const textures = [
                { name: 'wall', url: '/metrofps/assets/textures/wall.png' },
                { name: 'floor', url: '/metrofps/assets/textures/floor.png' },
                { name: 'ceiling', url: '/metrofps/assets/textures/ceiling.png' },
                { name: 'enemy', url: '/metrofps/assets/textures/enemy.png' }
            ];
            const sounds = [
                { name: 'shot', url: '/metrofps/assets/sfx/gun-shot-1680.mp3' },
                { name: 'reload', url: '/metrofps/assets/sfx/gun-reload-1910.mp3' },
                { name: 'hit', url: '/metrofps/assets/sfx/arrow-whoosh-1491.mp3' },
                { name: 'enemyDeath', url: '/metrofps/assets/sfx/ominous-drums-227.mp3' },
                { name: 'playerHurt', url: '/metrofps/assets/sfx/player-jumping-1929.mp3' }
            ];
            
            game.totalAssets = textures.length + sounds.length;
            
            textures.forEach(texture => {
                const img = new Image();
                img.onload = () => {
                    game.assets.textures[texture.name] = img;
                    assetLoaded();
                };
                img.onerror = () => {
                    console.warn(`Ошибка загрузки текстуры ${texture.name}, используем запасную`);
                    game.assets.textures[texture.name] = fallbackTextures[texture.name];
                    assetLoaded();
                };
                img.src = texture.url;
            });
            
            sounds.forEach(sound => {
                const audio = new Audio();
                audio.oncanplaythrough = () => {
                    game.assets.sounds[sound.name] = audio;
                    assetLoaded();
                };
                audio.onerror = () => {
                    console.warn(`Ошибка загрузки звука ${sound.name}`);
                    assetLoaded();
                };
                audio.src = sound.url;
            });
            
            function assetLoaded() {
                game.assetsLoaded++;
                const progress = Math.floor((game.assetsLoaded / game.totalAssets) * 100);
                loadingProgress.style.width = `${isNaN(progress) ? 0 : progress}%`;
                if (game.assetsLoaded === game.totalAssets) {
                    setTimeout(() => {
                        loadingScreen.style.display = 'none';
                        updateHealthDisplay();
                        updateAmmoDisplay();
                        updateWeaponDisplay();
                        requestAnimationFrame(gameLoop);
                    }, 500);
                }
            }
            
            setTimeout(() => {
                if (game.assetsLoaded < game.totalAssets) {
                    for (const texture in fallbackTextures) {
                        if (!game.assets.textures[texture]) {
                            game.assets.textures[texture] = fallbackTextures[texture];
                        }
                    }
                    loadingScreen.style.display = 'none';
                    updateHealthDisplay();
                    updateAmmoDisplay();
                    updateWeaponDisplay();
                    requestAnimationFrame(gameLoop);
                }
            }, 5000);
        }
        
        function gameLoop(timestamp) {
            if (game.isGameOver || game.isGameWon) return;
            const deltaTime = timestamp - game.lastTime || 16;
            game.lastTime = timestamp;
            
            game.frameTimes.push(deltaTime);
            if (game.frameTimes.length > 60) game.frameTimes.shift();
            const avgFrameTime = game.frameTimes.reduce((a, b) => a + b, 0) / game.frameTimes.length;
            game.fps = Math.round(1000 / avgFrameTime);
            
            update(Math.min(deltaTime, 33));
            render();
            requestAnimationFrame(gameLoop);
        }
        
        function update(deltaTime) {
            const moveSpeed = game.player.moveSpeed * (deltaTime / 16);
            const rotateSpeed = game.player.rotateSpeed * (deltaTime / 16);

            if (game.keys['w'] || game.keys['arrowup']) movePlayer(moveSpeed);
            if (game.keys['s'] || game.keys['arrowdown']) movePlayer(-moveSpeed * 0.7);
            if (game.keys['a'] || game.keys['arrowleft']) strafePlayer(-moveSpeed);
            if (game.keys['d'] || game.keys['arrowright']) strafePlayer(moveSpeed);
            
            updateBullets(deltaTime);
            updateEnemies(deltaTime);
            updateParticles(deltaTime);
        }
        
        function movePlayer(speed) {
            const newX = game.player.x + Math.cos(game.player.angle) * speed;
            const newY = game.player.y + Math.sin(game.player.angle) * speed;
            if (canMoveTo(newX, game.player.y)) game.player.x = newX;
            if (canMoveTo(game.player.x, newY)) game.player.y = newY;
        }
        
        function strafePlayer(speed) {
            const angle = game.player.angle + Math.PI/2;
            const newX = game.player.x + Math.cos(angle) * speed;
            const newY = game.player.y + Math.sin(angle) * speed;
            if (canMoveTo(newX, game.player.y)) game.player.x = newX;
            if (canMoveTo(game.player.x, newY)) game.player.y = newY;
        }
        
        function canMoveTo(x, y) {
            if (x < 0.3 || x >= game.map.width - 0.3 || y < 0.3 || y >= game.map.height - 0.3) return false;
            
            const mapX = Math.floor(x);
            const mapY = Math.floor(y);
            
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const checkX = mapX + dx;
                    const checkY = mapY + dy;
                    if (checkX >= 0 && checkX < game.map.width && checkY >= 0 && checkY < game.map.height) {
                        if (game.map.grid[checkY][checkX] === 1) {
                            const wallX = checkX + (dx > 0 ? 0 : 1);
                            const wallY = checkY + (dy > 0 ? 0 : 1);
                            const distX = x - wallX;
                            const distY = y - wallY;
                            if (Math.abs(distX) < 0.3 && Math.abs(distY) < 0.3) return false;
                        }
                    }
                }
            }
            
            for (const enemy of game.enemies) {
                const dx = x - enemy.x;
                const dy = y - enemy.y;
                const distance = Math.sqrt(dx*dx + dy*dy);
                if (distance < 0.5) return false;
            }
            return true;
        }
        
        function updateBullets(deltaTime) {
            for (let i = game.bullets.length - 1; i >= 0; i--) {
                const bullet = game.bullets[i];
                bullet.x += Math.cos(bullet.angle) * bullet.speed * (deltaTime / 16);
                bullet.y += Math.sin(bullet.angle) * bullet.speed * (deltaTime / 16);
                
                const mapX = Math.floor(bullet.x);
                const mapY = Math.floor(bullet.y);
                
                if (mapX < 0 || mapX >= game.map.width || mapY < 0 || mapY >= game.map.height || 
                    game.map.grid[mapY][mapX] === 1) {
                    createParticle(bullet.x, bullet.y, 5, '#ff0', 20);
                    if (game.assets.sounds.hit) {
                        const hitSound = game.assets.sounds.hit.cloneNode();
                        hitSound.volume = 0.3;
                        hitSound.play().catch(e => console.warn("Ошибка воспроизведения звука:", e));
                    }
                    game.bullets.splice(i, 1);
                    continue;
                }
                
                for (let j = game.enemies.length - 1; j >= 0; j--) {
                    const enemy = game.enemies[j];
                    const dx = bullet.x - enemy.x;
                    const dy = bullet.y - enemy.y;
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    if (distance < enemy.size) {
                        enemy.health -= bullet.damage;
                        createParticle(bullet.x, bullet.y, 10, '#f00', 30);
                        if (game.assets.sounds.hit) {
                            const hitSound = game.assets.sounds.hit.cloneNode();
                            hitSound.volume = 0.5;
                            hitSound.play().catch(e => console.warn("Ошибка воспроизведения звука:", e));
                        }
                        game.bullets.splice(i, 1);
                        
                        if (enemy.health <= 0) {
                            if (game.assets.sounds.enemyDeath) {
                                const deathSound = game.assets.sounds.enemyDeath.cloneNode();
                                deathSound.volume = 0.7;
                                deathSound.play().catch(e => console.warn("Ошибка воспроизведения звука:", e));
                            }
                            game.enemies.splice(j, 1);
                            if (game.enemies.length === 0) nextStation();
                        }
                        break;
                    }
                }
            }
        }
        
        function updateEnemies(deltaTime) {
            const now = Date.now();
            for (const enemy of game.enemies) {
                const dx = game.player.x - enemy.x;
                const dy = game.player.y - enemy.y;
                const distance = Math.sqrt(dx*dx + dy*dy);
                
                if (distance > 0.5) {
                    const angle = Math.atan2(dy, dx);
                    const newX = enemy.x + Math.cos(angle) * enemy.speed * (deltaTime / 16);
                    const newY = enemy.y + Math.sin(angle) * enemy.speed * (deltaTime / 16);
                    
                    const mapX = Math.floor(newX);
                    const mapY = Math.floor(newY);
                    if (mapX >= 0 && mapX < game.map.width && mapY >= 0 && mapY < game.map.height && 
                        game.map.grid[mapY][mapX] === 0) {
                        enemy.x = newX;
                        enemy.y = newY;
                    }
                }
                
                if (distance < 2 && now - enemy.lastAttack > enemy.attackCooldown) {
                    enemy.lastAttack = now;
                    game.player.health -= enemy.damage;
                    if (game.assets.sounds.playerHurt) {
                        const hurtSound = game.assets.sounds.playerHurt.cloneNode();
                        hurtSound.play().catch(e => console.warn("Ошибка воспроизведения звука:", e));
                    }
                    updateHealthDisplay();
                    if (game.player.health <= 0) gameOver();
                }
            }
        }
        
        function updateParticles(deltaTime) {
            for (let i = game.particles.length - 1; i >= 0; i--) {
                const particle = game.particles[i];
                particle.x += Math.cos(particle.angle) * particle.speed * (deltaTime / 16);
                particle.y += Math.sin(particle.angle) * particle.speed * (deltaTime / 16);
                particle.life -= deltaTime;
                if (particle.life <= 0) game.particles.splice(i, 1);
            }
            if (game.particles.length > 50) game.particles.splice(0, game.particles.length - 50);
        }
        
        function createParticle(x, y, count, color, life) {
            for (let i = 0; i < count; i++) {
                game.particles.push({
                    x: x,
                    y: y,
                    angle: Math.random() * Math.PI * 2,
                    speed: Math.random() * 0.1,
                    color: color,
                    size: Math.random() * 3 + 1,
                    life: Math.random() * life + life/2
                });
            }
        }
        
        function shoot() {
            const weapon = game.player.weapons[game.player.currentWeapon];
            const now = Date.now();
            
            if (weapon.ammo <= 0) {
                reloadWeapon();
                return;
            }
            
            if (now - weapon.lastShot < weapon.fireRate || weapon.isReloading) return;
            
            weapon.lastShot = now;
            weapon.ammo--;
            
            if (game.assets.sounds.shot) {
                const shotSound = game.assets.sounds.shot.cloneNode();
                shotSound.play().catch(e => console.warn("Ошибка воспроизведения звука:", e));
            }
            
            game.bullets.push({
                x: game.player.x,
                y: game.player.y,
                angle: game.player.angle,
                speed: 0.3,
                damage: weapon.damage
            });
            
            createParticle(
                game.player.x + Math.cos(game.player.angle) * 0.5,
                game.player.y + Math.sin(game.player.angle) * 0.5,
                2, '#ff0', 10
            );
            
            updateAmmoDisplay();
        }
        
        function reloadWeapon() {
            const weapon = game.player.weapons[game.player.currentWeapon];
            if (weapon.isReloading || weapon.ammo === weapon.maxAmmo || weapon.totalAmmo <= 0) return;
            
            weapon.isReloading = true;
            if (game.assets.sounds.reload) {
                const reloadSound = game.assets.sounds.reload.cloneNode();
                reloadSound.play().catch(e => console.warn("Ошибка воспроизведения звука:", e));
            }
            showMessage(`Reloading ${weapon.name}...`);
            
            setTimeout(() => {
                const ammoNeeded = weapon.maxAmmo - weapon.ammo;
                const ammoAvailable = Math.min(ammoNeeded, weapon.totalAmmo);
                weapon.ammo += ammoAvailable;
                weapon.totalAmmo -= ammoAvailable;
                weapon.isReloading = false;
                updateAmmoDisplay();
                updateWeaponDisplay();
                showMessage(`${weapon.name} reloaded`);
            }, weapon.reloadTime);
        }
        
        function updateHealthDisplay() {
            const healthPercent = (game.player.health / game.player.maxHealth) * 100;
            healthFill.style.width = `${isNaN(healthPercent) ? 0 : healthPercent}%`;
            if (healthPercent > 60) healthFill.style.backgroundColor = '#2ecc71';
            else if (healthPercent > 30) healthFill.style.backgroundColor = '#f39c12';
            else healthFill.style.backgroundColor = '#e74c3c';
        }
        
        function updateAmmoDisplay() {
            const weapon = game.player.weapons[game.player.currentWeapon];
            ammoDisplay.textContent = `${weapon.ammo}/${weapon.totalAmmo}`;
        }
        
        function updateWeaponDisplay() {
            const weapon = game.player.weapons[game.player.currentWeapon];
            weaponDisplay.textContent = weapon.name;
        }
        
        function showMessage(text) {
            messageDisplay.textContent = text;
            messageDisplay.style.opacity = 1;
            setTimeout(() => messageDisplay.style.opacity = 0, 3000);
        }
        
        function gameOver() {
            game.isGameOver = true;
            gameOverScreen.style.display = 'flex';
        }
        
        function nextStation() {
            game.map.currentStation++;
            if (game.map.currentStation >= game.map.stations.length) {
                game.isGameWon = true;
                gameWonScreen.style.display = 'flex';
            } else {
                showMessage(`Moving to ${game.map.stations[game.map.currentStation].name} station`);
                game.player.health = game.player.maxHealth;
                updateHealthDisplay();
                setTimeout(generateMap, 2000);
            }
        }
        
        function resetGame() {
            game.isGameOver = false;
            game.isGameWon = false;
            gameOverScreen.style.display = 'none';
            gameWonScreen.style.display = 'none';
            game.player.health = game.player.maxHealth;
            game.player.weapons[0].ammo = 30;
            game.player.weapons[0].totalAmmo = 90;
            game.player.weapons[1].ammo = 8;
            game.player.weapons[1].totalAmmo = 32;
            game.player.currentWeapon = 0;
            game.map.currentStation = 0;
            updateHealthDisplay();
            updateAmmoDisplay();
            updateWeaponDisplay();
            generateMap();
            requestAnimationFrame(gameLoop);
        }
        
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            game.zBuffer.fill(Infinity);
            draw3DView();
            drawParticles();
            drawHUD();
            ctx.fillStyle = 'white';
            ctx.font = '16px Arial';
            ctx.fillText(`FPS: ${game.fps}`, 10, 20);
        }
        
        function draw3DView() {
            const fov = Math.PI / 3;
            const halfFov = fov / 2;
            const rayStep = 4;
            const numRays = Math.floor(canvas.width / rayStep);
            const rayAngleStep = fov / numRays;
            for (let i = 0; i < numRays; i++) {
                const rayAngle = game.player.angle - halfFov + i * rayAngleStep;
                castRay(rayAngle, i * rayStep, rayStep);
            }
            drawEnemies();
        }
        
        function castRay(angle, column, rayStep) {
            let rayX = game.player.x, rayY = game.player.y;
            const rayDirX = Math.cos(angle), rayDirY = Math.sin(angle);
            let sideDistX, sideDistY;
            const deltaDistX = Math.abs(1 / rayDirX) || 1e10, deltaDistY = Math.abs(1 / rayDirY) || 1e10;
            let stepX, stepY, mapX = Math.floor(rayX), mapY = Math.floor(rayY);
            
            if (rayDirX < 0) { stepX = -1; sideDistX = (game.player.x - mapX) * deltaDistX; }
            else { stepX = 1; sideDistX = (mapX + 1.0 - game.player.x) * deltaDistX; }
            if (rayDirY < 0) { stepY = -1; sideDistY = (game.player.y - mapY) * deltaDistY; }
            else { stepY = 1; sideDistY = (mapY + 1.0 - game.player.y) * deltaDistY; }
            
            let hit = false, side, wallDist;
            while (!hit) {
                if (sideDistX < sideDistY) { sideDistX += deltaDistX; mapX += stepX; side = 0; }
                else { sideDistY += deltaDistY; mapY += stepY; side = 1; }
                if (mapX < 0 || mapX >= game.map.width || mapY < 0 || mapY >= game.map.height) { 
                    hit = true; 
                    wallDist = 100; 
                } else if (game.map.grid[mapY][mapX] === 1) {
                    hit = true;
                    wallDist = side === 0 ? (mapX - game.player.x + (1 - stepX) / 2) / rayDirX : 
                                          (mapY - game.player.y + (1 - stepY) / 2) / rayDirY;
                }
            }
            
            if (isNaN(wallDist) || wallDist <= 0) wallDist = 100;
            const lineHeight = Math.floor(canvas.height / (wallDist + 0.0001));
            let drawStart = -lineHeight / 2 + canvas.height / 2; if (drawStart < 0) drawStart = 0;
            let drawEnd = lineHeight / 2 + canvas.height / 2; if (drawEnd >= canvas.height) drawEnd = canvas.height - 1;

            let wallX = side === 0 ? game.player.y + wallDist * rayDirY : game.player.x + wallDist * rayDirX;
            wallX -= Math.floor(wallX);

            const texWidth = game.assets.textures.wall.width;
            const texX = Math.floor(wallX * texWidth);

            ctx.drawImage(
                game.assets.textures.wall,
                texX, 0, 1, game.assets.textures.wall.height,
                column, drawStart, rayStep, drawEnd - drawStart
            );

            for (let x = column; x < column + rayStep; x++) {
                if (x >= 0 && x < game.zBuffer.length) game.zBuffer[x] = wallDist;
            }

            drawFloorAndCeiling(column, drawStart, drawEnd, angle, wallDist);
        }
        
        function drawFloorAndCeiling(column, wallTop, wallBottom, angle, wallDist) {
            const rayStep = 4;
            const horizon = canvas.height / 2;
            for (let y = Math.max(wallBottom, horizon); y < canvas.height; y++) {
                const currentDist = canvas.height / (2.0 * y - canvas.height);
                const weight = currentDist / wallDist;
                const currentFloorX = weight * (game.player.x + Math.cos(angle) * wallDist) + (1.0 - weight) * game.player.x;
                const currentFloorY = weight * (game.player.y + Math.sin(angle) * wallDist) + (1.0 - weight) * game.player.y;
                const floorTexX = Math.floor(currentFloorX * 64) % 64;
                const floorTexY = Math.floor(currentFloorY * 64) % 64;
                ctx.drawImage(
                    game.assets.textures.floor,
                    floorTexX, floorTexY, 1, 1,
                    column, y, rayStep, 1
                );
            }
            for (let y = 0; y < Math.min(wallTop, horizon); y++) {
                const currentDist = canvas.height / (canvas.height - 2.0 * y);
                const weight = currentDist / wallDist;
                const currentCeilingX = weight * (game.player.x + Math.cos(angle) * wallDist) + (1.0 - weight) * game.player.x;
                const currentCeilingY = weight * (game.player.y + Math.sin(angle) * wallDist) + (1.0 - weight) * game.player.y;
                const ceilingTexX = Math.floor(currentCeilingX * 64) % 64;
                const ceilingTexY = Math.floor(currentCeilingY * 64) % 64;
                ctx.drawImage(
                    game.assets.textures.ceiling,
                    ceilingTexX, ceilingTexY, 1, 1,
                    column, y, rayStep, 1
                );
            }
        }
        
        function drawEnemies() {
            const sortedEnemies = [...game.enemies].sort((a, b) => {
                const distA = Math.sqrt(Math.pow(a.x - game.player.x, 2) + Math.pow(a.y - game.player.y, 2));
                const distB = Math.sqrt(Math.pow(b.x - game.player.x, 2) + Math.pow(b.y - game.player.y, 2));
                return distB - distA;
            });
            for (const enemy of sortedEnemies) drawEnemy(enemy);
        }
        
        function drawEnemy(enemy) {
            const dx = enemy.x - game.player.x;
            const dy = enemy.y - game.player.y;
            const distance = Math.sqrt(dx*dx + dy*dy);
            let angle = Math.atan2(dy, dx) - game.player.angle;
            while (angle < -Math.PI) angle += 2*Math.PI;
            while (angle > Math.PI) angle -= 2*Math.PI;
            
            const fov = Math.PI / 3;
            if (Math.abs(angle) > fov / 2) return;
            
            const enemyHeight = canvas.height / distance * enemy.size * 2;
            const enemyWidth = enemyHeight;
            const screenX = (angle + fov/2) / fov * canvas.width - enemyWidth/2;
            const screenY = canvas.height/2 - enemyHeight/2;
            
            const columnStart = Math.floor(screenX);
            const columnEnd = Math.ceil(screenX + enemyWidth);
            let visible = false;
            for (let x = columnStart; x < columnEnd; x++) {
                if (x >= 0 && x < game.zBuffer.length && distance < game.zBuffer[x]) {
                    visible = true;
                    break;
                }
            }
            if (!visible) return;
            
            ctx.drawImage(
                game.assets.textures.enemy,
                screenX, screenY,
                enemyWidth, enemyHeight
            );
            
            const healthPercent = enemy.health / enemy.maxHealth;
            const healthBarWidth = enemyWidth * 0.8;
            const healthBarHeight = 5;
            ctx.fillStyle = '#300';
            ctx.fillRect(screenX + enemyWidth * 0.1, screenY - 10, healthBarWidth, healthBarHeight);
            ctx.fillStyle = '#f00';
            ctx.fillRect(screenX + enemyWidth * 0.1, screenY - 10, healthBarWidth * healthPercent, healthBarHeight);
        }
        
        function drawParticles() {
            for (const particle of game.particles) {
                const dx = particle.x - game.player.x;
                const dy = particle.y - game.player.y;
                const distance = Math.sqrt(dx*dx + dy*dy);
                const angle = Math.atan2(dy, dx) - game.player.angle;
                let normalizedAngle = angle;
                while (normalizedAngle < -Math.PI) normalizedAngle += 2*Math.PI;
                while (normalizedAngle > Math.PI) normalizedAngle -= 2*Math.PI;
                
                const fov = Math.PI / 3;
                if (Math.abs(normalizedAngle) > fov / 2) continue;
                
                const particleSize = canvas.height / distance * particle.size;
                const screenX = (normalizedAngle + fov/2) / fov * canvas.width - particleSize/2;
                const screenY = canvas.height/2 - particleSize/2;
                
                const columnStart = Math.floor(screenX);
                const columnEnd = Math.ceil(screenX + particleSize);
                let visible = false;
                for (let x = columnStart; x < columnEnd; x++) {
                    if (x >= 0 && x < game.zBuffer.length && distance < game.zBuffer[x]) {
                        visible = true;
                        break;
                    }
                }
                if (!visible) continue;
                
                ctx.fillStyle = particle.color;
                ctx.globalAlpha = Math.min(particle.life / 100, 1.0);
                ctx.beginPath();
                ctx.arc(screenX + particleSize/2, screenY + particleSize/2, particleSize/2, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }
        
        function drawHUD() {
            const weapon = game.player.weapons[game.player.currentWeapon];
            const now = Date.now();
            const recoil = Math.min((now - weapon.lastShot) / 100, 1.0) * 0.1;
            ctx.fillStyle = '#555';
            ctx.fillRect(canvas.width * 0.4, canvas.height * 0.7 - canvas.height * recoil, canvas.width * 0.2, canvas.height * 0.2);
            
            if (weapon.isReloading) {
                const reloadProgress = (now - (weapon.lastShot + weapon.fireRate)) / weapon.reloadTime;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(canvas.width * 0.3, canvas.height * 0.8, canvas.width * 0.4, 10);
                ctx.fillStyle = '#f39c12';
                ctx.fillRect(canvas.width * 0.3, canvas.height * 0.8, canvas.width * 0.4 * reloadProgress, 10);
            }
        }
        
        initGame();
    </script>
</body>
</html>
